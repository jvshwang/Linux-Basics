##C指针运用
>起草人：马啸

###1 内存和地址
首先，要谨记两件事前：

1. 内存中的每个位置由一个独一无二的地址标识。
2. 内存中的每个位置都包含一个值。

举一个例子，这里显示了内存中5个字的内容。

![](http://i.imgur.com/GfOX7Rj.png)

这里显示了5个整数，每个都位于自己的字中。如果你记住了一个值的存储地址，你以后可以根据这个地址取得这个值。

但是要记住这些地址实在是太笨拙了，所以高级语言提供的特性之一就是通过名字而不是地址来访问内存的地址。下面这张图和上图相同，但这次使用名字来代替地址。

![](http://i.imgur.com/0Ig86Zl.png)

这些名字就是我们所称的变量。要注意一点，名字和内存位置之间的关联并不是硬件所提供的，他是编译器为我们实现的。这些变量给了我们一种更方便的方法记住地址，但硬件仍然通过地址访问内存位置。
###2 值和类型
下面是上述变量的声明：
    
    int 	a = 112,b = -1;
	float	c = 3.14;
	int		*d = &a;
	int		*e = &c;

可以看到，声明c所存储的是浮点数，可是上图中c的值是一个整数。那么到底它应该是哪个呢？
答案是该变量包含了一序列内容为0或者1的位。他们可以被解释为整数，也可以被解释为浮点数，这取决于他们被使用的方式。

不能简单地通过检查一个值的位置来判断它的类型，必须观察程序中这个值的使用方式。
###3 指针变量内容
d和e的内容是地址而不是整型或浮点型。d的内容与a的存储地址一致，e的内容与c的存储地址一致。一个变量的值就是分配给这个变量的内存位置所存储的数值，即使是指针变量也不例外。
###4 间接访问操作符
通过一个指针访问它所指向的地址的过程称为间接访问（indirection）或者解引用指针（dereferencing the pointer）。这个用于执行间接访问的操作符是单目操作符*。

![](http://i.imgur.com/32piC3A.png)

正常情况下，我们不知道编译器为每个变量所选择的存储位置，所以我们事先无法知道它们的地址。这样，我们绘制内存中的指针图时，用实际数值表示地址是不方便的。所以大部分书籍改用箭头来代替，如下图所示：

![](http://i.imgur.com/w2PVOeZ.png)

###5 未初始化和非法的指针
下面这个代码说明了一个极为常见的错误：

    int	*a;
	...
	*a = 12;

大家知道为什么错吗？

这个声明创建了一个名叫a的指针变量，后面那条赋值语句把12存在a所指向的内存位置。但是究竟a指向哪里呢？我们声明了这个变量，但从未对它进行初始化，所以我们没有办法预测12这个值将存储于什么地方。
###6 NULL指针
NULL指针的概念是非常有用的，它给了你一种方法，表示某个特定的指针目前并未指向任何东西。对一个NULL指针进行解引用操作是非法的，所以在对指针进行解引用操作之前，你首先必须确保它并非NULL指针。
###7 指针、间接访问和左值
给定下面这些声明。

    int		a;
	int 	*d = &a;

考虑下面的表达式：

![](http://i.imgur.com/h7AKDQ4.png)

指针变量可以作为左值，并不是因为它是指针，而是因为它是变量。对指针变量进行间接访问表示我们应该访问指针所指向的位置。间接访问指定了一个特定的内存位置，这样我们可以把间接访问表达式的结果作为左值使用。

    *d = 10 - *d;

右边的间接访问作为右值使用，所以它的值是d所指向的位置所存储的值（a的值）。左边的间接访问作为左值使用，所以d所指向的位置（a）把赋值符右边的表达式计算结果作为它的新值。
###8 指针、间接访问和变量
看看是否明白下面这个表达式的意思。

    *&a = 25;

首先，&操作符产生变量a的地址，他是一个指针常量。接着，*操作符访问其操作数所表示的地址。这个表达式中，操作数是a的地址，所以值25就存储于a中。
###9 指针常量
让我们分析另外一个表达式。假定a存储于位置100，下面这条语句的作用是什么？

    *100 = 25；

看上去像是把25赋值给a，因为a是位置100所存储的变量。但是，这是错的。100的类型是整型，而间接访问操作只能作用于指针类型表达式。如果要正确实现，必须用到强制类型转换。

    *(int *)100 = 25;

但是，需要使用这种技巧的机会是绝无仅有的。因为你无法预知编译器把某个特定变量放在内存中的什么位置。
###10 指针的指针
我们看一个例子。

    int a = 12;
	int *b = &a;

它们如下图所示进行内存分配：

![](http://i.imgur.com/px02BA0.png)

假定我们又有了第3个变量，名叫c，并用下面这条语句对它进行初始化：

    c = &b;

它们在内存中的模样大致如下：

![](http://i.imgur.com/IRryglO.png)

c是一个指向“指向整型的指针”的指针，更通俗的说，是一个指针的指针。这个变量的声明：

    int **c;

假定有如下声明：

    int		a = 12;
	int 	*b = &a;
	int 	**c = &b;

则有：

![](http://i.imgur.com/UbWwOxy.png)

###11 指针表达式
首先，我们来看一些声明。

    char ch = 'a';
	char *cp = &ch;

现在我们有了两个变量，它们初始化如下：

![](http://i.imgur.com/dj4X7mN.png)

图中显示了ch后面那个内存的位置。

首先以一个简单的表达式作为开始：

    ch

当它作为右值使用时，表达式的值为'a',如下图所示：

![](http://i.imgur.com/LYmFJ5c.png)

粗椭圆提示变量ch的值就是表达式的值。

当它作为左值时，如下图所示：

![](http://i.imgur.com/nK6frGw.png)

该位置用粗方框标记，提示这个位置就是表达式的结果。它的值并未显示，因为它并不重要。

接下来的表达式以表格的形式出现。每个表的后面是表达式求值过程的描述。

![](http://i.imgur.com/pJvLFWV.png)

上面表达式并未标识任何机器内存的特定位置，所以不是一个合法的左值。

![](http://i.imgur.com/Vf5Kqv0.png)

由于上面这个表达式并不进行间接访问操作，所以不必依箭头所示进行间接访问。

![](http://i.imgur.com/FhQf3vb.png)

上面表达式中，这个值的存储位置并未清晰定义，所以这个表达式不是一个合法的左值。

![](http://i.imgur.com/tmyf9Ta.png)

上面这个表达式引入了间接访问操作，它的结果并不令人感到惊奇。

![](http://i.imgur.com/8B6jvAZ.png)

这里有两个操作符。*的优先级高于+，所以首先执行间接访问操作，我们可以得到它的值（虚线椭圆）。我们取得这个值的一份拷贝并把它与1相加，表达式的最终结果为字符'b'。这个表达式的最终结果的存储位置并未清晰定义，所以它不是一个合法的左值。

![](http://i.imgur.com/SPJwaDX.png)

括号使表达式先执行加法运算，就是把1和cp中所存储的地址相加。此时结果是图中虚线椭圆所示的指针。接下来的间接访问操作随着箭头访问紧随ch之后的内存位置。这样这个表达式的右值就是这个位置的值，而它的左值就是这个位置本身。

试想一下，指针加法运算的结果可以是一个左值吗？

一般而言，我们不知道原先存储于ch后面那个内存位置的是什么东西，所以像这样的表达式是非法的。

![](http://i.imgur.com/ibWtDH4.png)

因为前缀++先增加它的操作数的值再返回这个结果，所以表达式的结果是增值后的指针的一份拷贝。这份拷贝的存储位置未清晰定义，所以它不是一个合法的左值。

![](http://i.imgur.com/eXgSZGx.png)

后缀++先返回cp值的一份拷贝然后再增加cp的值。这样，这个表达式的值就是cp原来的值的一份拷贝。

![](http://i.imgur.com/JXuNmCQ.png)

间接访问操作符作用于增值后的指针的拷贝上，所以它的右值是ch后面那个内存地址的值，而它的左值就是那个位置本身。

![](http://i.imgur.com/BgBEwnh.png)

表达式的右值是变量ch的值，左值是ch的内存位置。优先级表格显示后缀++操作符的优先级高于*操作符，但表达式的结果看上去像是先执行间接访问操作。事实上，这里涉及3个步骤：

1. ++操作符产生cp的一份拷贝，
2. 然后++操作符增加cp的值，
3. 最后，在cp的拷贝上执行间接访问操作。

![](http://i.imgur.com/iGaVA5y.png)

在这个表达式中，由于这两个操作数的结合性都是从右向左，所以先执行的是间接访问操作。然后，cp所指向的位置的值增加1，表达式的结果是这个增值后的值的一份拷贝。

下面3个表达式在实际使用中使用得少。但是，对它们有一个透彻的理解有利于提高技能。

![](http://i.imgur.com/EI1H07V.png)

使用后缀++操作符，这次加上括号，使它首先执行间接访问操作。这个表达式的计算过程与前一个表达式相似，但是它的结果是ch增值前的原先值。

![](http://i.imgur.com/DpRZuYQ.png)

这个表达式相当诡异，但事实上并不复杂。

![](http://i.imgur.com/AqLJR8M.png)

这个表达式和前一个表达式的区别在于第1个++操作符是后缀形式而不是前缀形式。

###12 实例
这里有一个例子程序，用于说明表达式的一些常见用法。该程序用于计算一个字符串的长度。

    #include<stdlib.h>
	size_t
	strlen(char * string)
	{
		int 	length = 0;
		
		while(*string++ != '\0')
			length += 1;

		return length;
	}
当函数调用时给他传的是一个NULL指针，会怎么样？while语句中的间接访问将会失败。

当指针创建的时检查它是否有效是合乎逻辑的，因为这样只需要检查一次。

###13 指针运算
当一个指针和一个整数量执行算术运算时，整数在执行加法运算前会始终根据合适的大小进行调整。

![](http://i.imgur.com/Gb2UTQF.png)

####算术运算

C的指针运算只限于两种形式。第1种形式是：

指针	+- 整数

标准定义这种形式只能用于指向数组中某个元素的指针，如下图所示。

![](http://i.imgur.com/5NW1XQk.png) 

对一个指针加1使它指向数组下一个元素，加5使它向右移动5个元素，以此类推。把一个指针减去3使它向左移动3个元素的位置。

第2种类型的指针运算具有如下形式：

指针 - 指针

只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针，如下图所示：

![](http://i.imgur.com/ZtIBL0r.png)

两个指针相减的结果类型是ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位）。

####关系运算

对于两个指针，它们指向同一个数组中的元素，那么它们可以用下列关系操作符进行比较：

<	<=	>	>=

比较表达式告诉你哪个指针指向数组更前或更后的元素。

我们观察一个循环，它用于清除一个数组中所有的元素。

    #define N_VALUES 5
	float	values[N_VALUES];
	float	*vp;

	for( vp = &values[0]; vp < &values[N_VALUES];)
		*vp++ = 0;

vp和指针常量都指向同一数组中的元素，所以用 < 是合法的。指针常量指向的是数组最后一个元素后面的那个内存位置，vp在最后一次比较时，也指向了这个位置，但是我们并未对vp执行间接访问操作，所以它是安全的。

考虑下面这个循环：

    for( vp = &values[N_VALUES]; vp > &values[0];)
			*--vp = 0;

它和前面那个循环所执行的任务相同，但数组元素将以相反的次序清除。vp指向数组最后那个元素后面的内存位置，但在对它进行间接访问之前先执行自减操作。当vp指向第1个元素时，循环终止，不过这时第1个数组元素已经被清除了。

我们对这个循环进行“简化”，看看会发生什么。

    for( vp = &values[N_VALUES - 1]; vp >= &values[0];vp--)
			*vp = 0;

大家知道哪里有问题吗？

数组的第1个元素被清除后，vp的值还减去1，而接下去的一次比较运算是用于结束循环的。但这就是问题所在：比较表达式vp>=&value[0]的值是未定义的，因为vp移到了数组的边界之外。标准允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针进行比较，但不允许与指向数组第1个元素之前的那个内存位置的指针进行比较。

事实上，绝大多数C编译器中，这个循环将顺利完成任务。然而，标准并不保证它可行，你迟早会遇到一台这个循环将失败的机器。所以你还是要避免使用它。

###14 指针作为函数参数

下面的函数试图交换传给它的两个参数，然而并没有成功。

    void
	swap(int x , int y)
	{
		int temp;
		
		temp = x;
		x = y;
		y = temp;
	}

下面的函数则能够成功交换两个参数。

    void
	swap(int *x, int *y)
	{
		int temp;
		
		temp = *x;
		*x = *y;
		*y = temp;
	}

如果要调用，则需要用这样做：

    swap(&a, &b);
##数组与指针
###1 指针与下标
在可读性方面，下标有一定的优势。但在另一方面，这个选择会影响运行时的效率。

假定这两种方法都是正确的，下标绝不会比指针更有效率，但指针有时会比下标更有效率。
###2 指针的效率
指针有时比下标更有效率，前提是它们被正确的使用。
###3 数组和指针的区别
指针和数组并不是相等的。为了说明这个概念，请考虑下面这两个声明：

    int 	a[5];
	int 	*b;

a和b都具有指针值，它们都可以进行间接访问和下标引用操作。但是，它们还是存在相当大的区别。

把这两个声明用图的方法来表示，你可以发现它们之间存在显著不同。

![](http://i.imgur.com/bhzypfk.png)

上述声明之后，*a是完全合法的，但是表达式\*b确实非法的。\*b将访问内存中某个不确定的位置，或者导致程序终止。另一方面，表达式b++可以通过编译，但a++却不行，因为a的值是个常量。
###4 指向数组的指针
请看下面的声明，它们合法吗？

    int 	vector[10], *vp = vector;
	int 	matrix[3][10], *mp = matrix;

第1个声明是合法的。但是第2个声明是非法的。它正确地创建了matrix数组，并把mp声明为一个指向整型的指针。但是对mp的初始化是不正确的。因为matrix并不是指向整型的指针，而是一个指向整型数组的指针。

一个指向整型数组的指针应该这样声明。

    int 	(*p)[10];

在声明中加上初始化后是这个样子：

    int 	(*p)[10] = matrix;

它使p指向matrix的第1行。p是一个指向拥有10个整型元素的数组的指针。我们可以用这个指针一行一行地在matrix中移动。

如果你需要一个指针逐个访问整型元素而不是逐行在数组中移动，该怎么办？下面两个声明都创建了一个简单的整型指针，并以两种不同的方式进行初始化，指向matrix的第1个整型元素。

    int 	*pi = &matrix[0][0];
	int 	*pi = matirx[0];

增加这个指针的值使它指向下一个整型元素。
###5 指针数组
除了类型外，指针变量和其它变量很相似。正如你可以创建整型数组一样，你也可以声明指针数组。例如：

    int 	*api[10];

什么地方会使用指针数组呢，这里有一个例子：

    char 	const	*keyword[] = {
			"do",
			"for",
			"if",
			"register",
			"return",
			"switch",
			"while"
	};
	#define N_KEYWORD (sizeof(keyword) / sizeof(keyword[0]))

这个声明创建了一个指针数组，每个指针元素都初始化为指向各个不同的字符串常量，如下图所示：

![](http://i.imgur.com/IM79GxL.png)

这个数组可以用于一个计算C源文件中关键字个数的程序中。输入的每个单词都将与列表中的字符串进行比较，所有的匹配都将被计数。下面这个程序遍历整个关键字列表，查找是否存在与参数字符串相同的匹配。当它找到一个匹配时，函数就返回这个匹配在列表中的偏移量。调用程序必须知道0代表do，1代表for等，此外它还必须知道返回值如果是-1表示没有关键字匹配。

    #include<string.h>
	
	int
	lookup_keyword( char const * const desired_word ,
	 char const * keyword_table[] , int const size){
			char const **kwp;

			//对于表中的每个单词...
			for( kwp = keyword_table; kwp < keyword_table + size; kwp++)
					
					//如果这个单词与我们所查到的单词匹配，返回它在表中的位置。
					if(strcmp( desired_word, *kwp) == 0)
							return kwp - keyword_table;

					//没有找到。
					return -1;
	}

实际上，人们时常选择指针数组方案时，会略微对其作些改变：

       char 	const	*keyword[] = {
			"do",
			"for",
			"if",
			"register",
			"return",
			"switch",
			"while",
			NULL
	};

这里，我们在表的末尾增加了一个NULL指针。这个NULL指针使函数在搜索这个表时能够检测到表的结束，而无需预先知道表的长度，如下所示：

    for( kwp = keyword_table; *kwp != NULL; kwp++)

##函数指针
函数指针最常见的两个用途是转换表（jump table）和作为参数传递给另一个函数。
###1 回调函数
这里有一个简单的函数，它用于在一个单链表中查找一个值，它的参数是一个指向链表第1个节点的指针以及那个需要查找的值。

    Node * 
	search_list( Node * node , int const value)
	{
		while( node ！= NULL)
		{
			if(node->value == value)
				break;
				node = node -> link;
		}
		return node;
	}

这个函数看上去非常简单，但它只适用于值为整数的链表。如果你需要在一个字符串链表中查找，你不得不另外编写一个函数。这个函数和上面那个函数的绝大部分代码相同，只是第2个参数的类型以及节点值的比较方法不同。

一种更为通用的方法就是使查找函数与类型无关，这样它就能用于任何类型的值的链表。我们必须对函数的两个方面进行修改。

1. 改变比较的执行方式，这样函数就可以对任何类型的值进行比较。这就要用到函数指针。调用者编写一个函数，用于比较两个值，然后把一个指向这个函数的指针作为参数传递给查找函数。然后查找函数就调用这个函数进行值的比较。
2. 必须修改的第2个方面是向函数传递一个指向值的指针而不是值本身。

下面是一个类型无关查找函数的一种实现方法。

    #include<stdio.h>
	#include"node.h"

	Node *
	search_list( Node * node, void const *value,
	int (*compare)(void const * , void const * ))
	{
			while( node != NULL)
			{
				if(compare( &node->value, value) == 0)
					break;
				node = node->link;	
			}
			return;
	}

如果你希望在一个字符串链表中进行查找，下面的代码可以完成这项任务：

    #include<string.h>
	...
	desired_node = search_list(root,"desired_value",strcmp);

库函数strcmp所执行的比较和我们需要的完全一样，不过有些编译器会发出警告信息，因为它的参数被声明为char*而不是void\*。
###2 转换表
转换表最好用一个例子来解释。下面的代码段取自一个程序，它用于实现一个袖珍式计算器。程序的其他部分已经读入两个数（op1和op2）和一个操作符（oper）。下面的代码对操作符进行测试，然后决定调用哪个函数。

    switch(oper)
	{
		case ADD:
				result = add( op1,op2);
				break;
		case SUB:
				result = sub( op1,op2);
				break;
		case MUL:
				result = mul( op1,op2);
				break;
		case DIV:
				result = div( op1,op2);
				break;
	...
	}

对于一个新奇的具有上百个操作符的计算器，这条switch语句会非常之长。

创建一个转换表需要两个步骤，首先声明并初始化一个函数指针数组。唯一需要留心之处就是确保这些函数的原型出现在这个数组的声明之前。

    double add(double , double);
	double sub(double , double);
	double mul(double , double);
	double div(double , double);
	...
	double (*oper_func[])(double , double) = {
			add,sub,mul,div,...
	};

初始化列表中各个函数名的正确顺序取决于程序中用于表示每个操作符的整型代码。这个例子假定ADD是0，SUB是1，MUL是2，以此类推。

第2个步骤是用下面这条语句替换前面整条switch语句。

    result = oper_func[ oper]( op1,op2);

oper从数组中选择正确的函数指针，而函数调用操作符将执行这个函数。
